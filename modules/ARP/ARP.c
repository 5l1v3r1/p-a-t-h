/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of ARP.xs. Do not edit this file, edit ARP.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "ARP.xs"
/*
Perl ARP Extension
Create and send an arp packet

Programmed by Bastian Ballmann
Last update: 16.01.2004

This program is free software; you can redistribute 
it and/or modify it under the terms of the 
GNU General Public License version 2 as published 
by the Free Software Foundation.

This program is distributed in the hope that it will 
be useful, but WITHOUT ANY WARRANTY; without even 
the implied warranty of MERCHANTABILITY or FITNESS 
FOR A PARTICULAR PURPOSE. 
See the GNU General Public License for more details. 
*/

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"
#include <stdio.h>           
#include <stdlib.h>          
#include <string.h>          
#include <errno.h>           
#include <net/ethernet.h>    
#include <net/if.h>
#include <arpa/inet.h>       
#include "arp.h"

#line 44 "ARP.c"
XS(XS_path__ARP_send_packet); /* prototype to pass -Wmissing-prototypes */
XS(XS_path__ARP_send_packet)
{
    dXSARGS;
    if (items != 6)
	Perl_croak(aTHX_ "Usage: path::ARP::send_packet(dev, sip, dip, smac, dmac, type)");
    {
	unsigned char *	dev = (unsigned char *)SvPV_nolen(ST(0));
	unsigned char *	sip = (unsigned char *)SvPV_nolen(ST(1));
	unsigned char *	dip = (unsigned char *)SvPV_nolen(ST(2));
	unsigned char *	smac = (unsigned char *)SvPV_nolen(ST(3));
	unsigned char *	dmac = (unsigned char *)SvPV_nolen(ST(4));
	unsigned char *	type = (unsigned char *)SvPV_nolen(ST(5));
#line 46 "ARP.xs"
	  int uid;
	  unsigned int packetsize = sizeof(struct arphdr) + sizeof(struct ether_header);
	  unsigned char packet[packetsize];
	  struct ether_header *ethhdr = (struct ether_header *)packet;
	  struct arphdr *arp = (struct arphdr *)(packet + sizeof(struct ether_header));
	  u_short op;	

	  // Are you root?
	  uid = getuid();
	  if(uid != 0) 
	  { 
	    printf("You must have UID 0 instead of %d.\n",uid); 
	    exit(1); 
	  }

	  // Initialize packet buffer 
	  memset(packet,0,packetsize);

	  // What's the ARP operation type?
	  if(!strcmp(type,"request"))
	  {
	    op = ARPOP_REQUEST;
	  }
	  else if(!strcmp(type,"reply"))
	  {
	    op = ARPOP_REPLY;
	  }
	  else if(!strcmp(type,"revrequest"))
	  {
	    op = ARPOP_REVREQUEST;
	  }
	  else if(!strcmp(type,"revreply"))
	  {
	    op = ARPOP_REVREPLY;
	  }
	  else if(!strcmp(type,"invrequest"))
	  {
	    op = ARPOP_INVREQUEST;
	  }
	  else if(!strcmp(type,"invreply"))
	  {
	    op = ARPOP_INVREPLY;
	  }
	  else
	  {
	    op = ARPOP_REPLY;
	  }

	  // Ethernet header
	  memcpy(ethhdr->ether_dhost,(u_char *)ether_aton(dmac),ETHER_ADDR_LEN); // Destination MAC
	  memcpy(ethhdr->ether_shost,(u_char *)ether_aton(smac),ETHER_ADDR_LEN); // Source MAC
	  ethhdr->ether_type = htons(ETHERTYPE_ARP);                             // ARP protocol

	  // ARP header
	  arp->hw_type = htons(ARPHDR_ETHER);                                    // Hardware address type
	  arp->proto_type = htons(ETH_P_IP);                                     // Protocol address type
	  arp->ha_len = ETH_ALEN;                                                // Hardware address length
	  arp->pa_len = IP_ALEN;                                                 // Protocol address length
	  arp->opcode = htons(op);                                               // ARP operation
	  memcpy(arp->source_add,(u_char *)ether_aton(smac),ETH_ALEN);           // Source MAC
	  *(u_long *)arp->source_ip = inet_addr(sip);                            // Source IP
	  memcpy(arp->dest_add,(u_char *)ether_aton(dmac),ETH_ALEN);             // Destination MAC
	  *(u_long *)arp->dest_ip = inet_addr(dip);                              // Destination IP


	  // Run packet!! Run!
	  // FreeBSD code
	  if(SOCK_TYPE == SOCK_RAW)
	  {
	     send_packet_bsd(dev,packet,packetsize);	
	  }

	  // Linux code
	  else
	  {
	     send_packet_linux(dev,packet,packetsize);
	  }
#line 136 "ARP.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_path__ARP_get_mac); /* prototype to pass -Wmissing-prototypes */
XS(XS_path__ARP_get_mac)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: path::ARP::get_mac(dev, mac)");
    {
	unsigned char *	dev = (unsigned char *)SvPV_nolen(ST(0));
	unsigned char *	mac = (unsigned char *)SvPV_nolen(ST(1));
	char *	RETVAL;
	dXSTARG;
#line 129 "ARP.xs"
          char tmp[20];

	  if(SOCK_TYPE == SOCK_RAW)
	  {
	    get_mac_bsd(dev,tmp);
	  }
	  else
	  {
	    get_mac_linux(dev,tmp);
	  }

	  mac = tmp;

#line 166 "ARP.c"
	sv_setpv((SV*)ST(1), mac);
	SvSETMAGIC(ST(1));
    }
    XSRETURN(1);
}

XS(XS_path__ARP_arp_lookup); /* prototype to pass -Wmissing-prototypes */
XS(XS_path__ARP_arp_lookup)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: path::ARP::arp_lookup(dev, ip, mac)");
    {
	unsigned char *	dev = (unsigned char *)SvPV_nolen(ST(0));
	unsigned char *	ip = (unsigned char *)SvPV_nolen(ST(1));
	unsigned char *	mac = (unsigned char *)SvPV_nolen(ST(2));
	char *	RETVAL;
	dXSTARG;
#line 152 "ARP.xs"
	  char tmp[20];

	  if(SOCK_TYPE == SOCK_RAW)
	  {
	    arp_lookup_bsd(dev,ip,tmp);
	  }
	  else
	  {
	    arp_lookup_linux(dev,ip,tmp);
	  }

	  mac = tmp;

#line 199 "ARP.c"
	sv_setpv((SV*)ST(2), mac);
	SvSETMAGIC(ST(2));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_path__ARP); /* prototype to pass -Wmissing-prototypes */
XS(boot_path__ARP)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("path::ARP::send_packet", XS_path__ARP_send_packet, file);
        newXS("path::ARP::get_mac", XS_path__ARP_get_mac, file);
        newXS("path::ARP::arp_lookup", XS_path__ARP_arp_lookup, file);
    XSRETURN_YES;
}

